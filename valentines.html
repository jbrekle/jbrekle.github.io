<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MoJo's Valentines Adventure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Reset and full-window styles */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #ffeef8;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    /* Main game canvas */
    #gameCanvas {
      background: #ffeef8;
    }
    /* Overlays: Menu, Pause, Win */
    .menu-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.98);
      z-index: 20;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    .menu-button, .avatar-button {
      padding: 10px 20px;
      border: none;
      border-radius: 8px;
      margin: 10px;
      cursor: pointer;
      font-size: 1.2em;
    }
    .menu-button {
      background: #ff99a0;
      color: #fff;
    }
    .avatar-button {
      background: #ffccdd;
      border: 2px solid #ff6699;
      color: #333;
    }
    .selected {
      background: #ff6699;
      color: #fff;
    }
    /* Explanation text on start screen */
    #menuOverlay p.explanation {
      width: 80%;
      font-size: 1.1em;
      margin-bottom: 20px;
    }
    /* Animated canvas inside the start overlay */
    #menuAnim {
      border: 1px solid transparent;
      background: #ffeef8;
      margin-bottom: 20px;
    }
    /* Pause overlay */
    #pauseOverlay {
      z-index: 30;
      display: none;
    }
    /* Win overlay with its own animation canvas */
    #winOverlay {
      z-index: 40;
      display: none;
      flex-direction: column;
    }
    #winAnim {
      border: 1px solid transparent;
      background: #ffeef8;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <!-- Main game canvas -->
  <canvas id="gameCanvas"></canvas>
  
  <!-- Start/Menu overlay -->
  <div id="menuOverlay" class="menu-overlay">
    <!-- Animated canvas for start screen visuals -->
    <div id="startAnim" style="position:relative; width:400px; height:150px;">
      <canvas id="menuAnim" width="400" height="150" style="position:absolute; top:0; left:0;"></canvas>
    </div>
    <p class="explanation">
      Welcome!<br><br>
      • Collect hearts and stars for points.<br>
      • Rescue pandas by dragging them into your backpack.<br>
      • Shooting pandas is ignored.<br>
      • Colliding with obstacles reduces your score by 5.<br>
      • Reach 200 points per level to advance.
    </p>
    <div id="avatarSelection">
      <button class="avatar-button" onclick="selectAvatar('Mona')" id="btnMona">Mona</button>
      <button class="avatar-button" onclick="selectAvatar('Jonas')" id="btnJonas">Jonas</button>
    </div>
    <button class="menu-button" onclick="startGame()">Start Game</button>
  </div>
  
  <!-- Pause overlay -->
  <div id="pauseOverlay" class="menu-overlay">
    <h1 style="color:#ff6699;">Paused</h1>
    <button class="menu-button" onclick="resumeGame()">Resume</button>
    <button class="menu-button" onclick="changeAvatar()">Change Character</button>
  </div>
  
  <!-- Win overlay -->
  <div id="winOverlay" class="menu-overlay">
    <h1 style="color:#ff6699; font-size:2.8em;">Congratulations!</h1>
    <p style="font-size:1.3em;">You completed MoJo's Valentines Adventure</p>
    <p id="stats" style="font-size:1.2em;"></p>
    <canvas id="winAnim" width="600" height="300"></canvas>
    <button class="menu-button" onclick="restartGame()">Play Again</button>
  </div>
  
  <script>
    // ================== SETUP CANVAS ==================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    // ================== GLOBAL VARIABLES ==================
    let gameState = "menu"; // "menu", "playing", "paused", "win"
    let currentLevelIndex = 0;
    const levelThresholds = [200, 400, 600];
    let scrollOffset = 0;
    let score = 0;
    let lastTime = 0;
    let spawnTimer = 0;
    let selectedAvatar = null;
    
    // Arrays for game objects
    let player;
    let projectiles = [];
    let targets = [];       // hearts, stars, pandas
    let obstacles = [];
    let decorations = [];
    let clouds = [];
    let birds = [];
    let spaceStars = [];
    let particles = [];
    let pointAnimations = [];
    let logMessages = [];
    let rescuedPandas = [];
    
    // Win screen arrays
    let winDancingPandas = [];
    let winFallingTargets = [];
    
    // Global flags
    let paused = false;
    let playerShakeTime = 0;     // ms for shake on obstacle collision
    let backpackJiggleTime = 0;   // ms for backpack jiggle after panda is collected
    
    // Menu animation variables (declared once)
    const menuAnimCanvas = document.getElementById("menuAnim");
    const menuAnimCtx = menuAnimCanvas.getContext("2d");
    let menuAnimTime = 0;
    
    // Win screen animation timer variable
    let globalLastWinTime = 0;
    
    // ================== LEVELS ==================
    const levels = [
      {
        name: "City",
        scrollSpeed: 120,
        groundColor: "#dddddd",
        groundPattern: null,
        decorationTypes: ["building", "lamp"],
        createDecoration: function(x, y) {
          let type = Math.random() < 0.7 ? "building" : "lamp";
          return new Decoration(type, x, y, this.name);
        },
        skyColor: "#a3d9ff",
        cloudColor: "rgba(255,255,255,0.8)"
      },
      {
        name: "Forest",
        scrollSpeed: 100,
        groundColor: "#c8e6c9",
        groundPattern: null,
        decorationTypes: ["tree", "bush"],
        createDecoration: function(x, y) {
          let type = Math.random() < 0.7 ? "tree" : "bush";
          return new Decoration(type, x, y, this.name);
        },
        skyColor: "#aaffaa",
        cloudColor: "rgba(255,255,255,0.8)"
      },
      {
        name: "Space",
        scrollSpeed: 80,
        groundColor: "#222",
        groundPattern: null,
        decorationTypes: ["satellite", "comet"],
        createDecoration: function(x, y) {
          let type = Math.random() < 0.5 ? "satellite" : "comet";
          return new Decoration(type, x, y, this.name);
        },
        skyColor: "#000",
        cloudColor: null
      }
    ];
    
    function createGroundPattern(color, detail) {
      const patCanvas = document.createElement('canvas');
      patCanvas.width = 50;
      patCanvas.height = 50;
      const pctx = patCanvas.getContext('2d');
      pctx.fillStyle = color;
      pctx.fillRect(0, 0, 50, 50);
      if(detail === "City") {
        pctx.strokeStyle = "rgba(0,0,0,0.1)";
        pctx.lineWidth = 1;
        pctx.beginPath();
        pctx.moveTo(0, 25);
        pctx.lineTo(50, 25);
        pctx.moveTo(25, 0);
        pctx.lineTo(25, 50);
        pctx.stroke();
      } else if(detail === "Forest") {
        pctx.strokeStyle = "rgba(0,150,0,0.3)";
        for(let i = 0; i < 50; i += 5){
          pctx.beginPath();
          pctx.moveTo(i, 0);
          pctx.lineTo(i, 50);
          pctx.stroke();
        }
      } else if(detail === "Space") {
        pctx.fillStyle = "rgba(255,255,255,0.1)";
        for(let i = 0; i < 8; i++){
          pctx.beginPath();
          pctx.arc(Math.random()*50, Math.random()*50, 1, 0, Math.PI*2);
          pctx.fill();
        }
      }
      return ctx.createPattern(patCanvas, 'repeat');
    }
    levels[0].groundPattern = createGroundPattern("#eeeeee", "City");
    levels[1].groundPattern = createGroundPattern("#dcedc8", "Forest");
    levels[2].groundPattern = createGroundPattern("#444", "Space");
    
    // ================== UTILITY FUNCTIONS ==================
    Math.clamp = function(val, min, max) { return Math.min(Math.max(val, min), max); };
    function getScaleForY(y) {
      const base = 0.5;
      const factor = 1 + (y / canvas.height);
      return base * factor;
    }
    function randomHeartLabel() {
      const words = ["Love", "Care", "Trust", "Passion", "Admire", "Cherish", "Devotion", "Adore", "Fondness", "Embrace"];
      return words[Math.floor(Math.random() * words.length)];
    }
    function randomStarLabel() {
      const words = ["Dream", "Achieve", "Inspire", "Shine", "Grow", "Believe", "Aspire", "Soar", "Flourish", "Radiate"];
      return words[Math.floor(Math.random() * words.length)];
    }
    function addLogMessage(text) {
      logMessages.push({ text, time: 0, lifetime: 2000 });
    }
    function addPointAnimation(text, x, y) {
      pointAnimations.push({ text, x, y, time: 0, lifetime: 1000 });
    }
    function drawRoundedRect(ctx, x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
    }
    
    // ================== PLAYER CLASS ==================
    class Player {
      constructor(avatar) {
        this.avatar = avatar; // "Mona" or "Jonas"
        this.width = Math.max(100, canvas.width * 0.1);
        this.height = this.width * 1.6;
        this.x = canvas.width / 2;
        this.y = canvas.height - 10;
        this.speed = 400;
        this.walkTime = 0;
        this.shakeOffset = { x: 0, y: 0 };
        this.backpack = { 
          x: this.x - this.width * 0.3, 
          y: this.y - this.height * 0.65, 
          width: this.width * 0.6, 
          height: this.height * 0.4 
        };
        this.backpackJiggleTime = 0;
      }
      update(deltaTime) {
        this.width = Math.max(100, canvas.width * 0.1);
        this.height = this.width * 1.6;
        this.y = canvas.height - 10;
        this.x = Math.clamp(this.x, this.width/2, canvas.width - this.width/2);
        this.walkTime += deltaTime;
        this.backpack.x = this.x - this.width * 0.3;
        this.backpack.y = this.y - this.height * 0.65;
        this.backpack.width = this.width * 0.6;
        this.backpack.height = this.height * 0.4;
        if (playerShakeTime > 0) {
          playerShakeTime -= deltaTime;
          this.shakeOffset.x = (Math.random()-0.5)*10;
          this.shakeOffset.y = (Math.random()-0.5)*10;
        } else {
          this.shakeOffset.x = 0;
          this.shakeOffset.y = 0;
        }
        if(this.backpackJiggleTime > 0) {
          this.backpackJiggleTime -= deltaTime;
        }
      }
      draw(ctx) {
        ctx.save();
        ctx.translate(this.shakeOffset.x, this.shakeOffset.y);
        // Draw body with striped texture.
        const patCanvas = document.createElement('canvas');
        patCanvas.width = 20;
        patCanvas.height = 20;
        const pctx = patCanvas.getContext('2d');
        pctx.fillStyle = this.avatar === "Mona" ? "#ffccd5" : "#ffe0b3";
        pctx.fillRect(0, 0, 20, 20);
        pctx.strokeStyle = "#ff99a0";
        for (let i = 0; i < 20; i += 4) {
          pctx.beginPath();
          pctx.moveTo(i, 0);
          pctx.lineTo(i, 20);
          pctx.stroke();
        }
        const pattern = ctx.createPattern(patCanvas, 'repeat');
        ctx.fillStyle = pattern;
        ctx.shadowBlur = 8;
        ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.fillRect(this.x - this.width/2, this.y - this.height, this.width, this.height);
        
        // Draw arms.
        const armOffset = Math.sin(this.walkTime / 150) * 8;
        ctx.fillStyle = "#ffe0bd";
        ctx.beginPath();
        ctx.arc(this.x - this.width/2 - 15, this.y - this.height + 20 + armOffset, 5, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + this.width/2 + 15, this.y - this.height + 20 - armOffset, 5, 0, Math.PI*2);
        ctx.fill();
        
        // Draw legs.
        const legOffset = Math.abs(Math.sin(this.walkTime / 150)) * 5;
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(this.x - 10, this.y + 20 + legOffset, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x + 10, this.y + 20 + legOffset, 4, 0, Math.PI*2);
        ctx.fill();
        
        // Draw head (larger for cuteness).
        const headX = this.x;
        const headY = this.y - this.height - 20;
        const headRadius = 25;
        const headGrad = ctx.createRadialGradient(headX, headY, headRadius * 0.5, headX, headY, headRadius);
        headGrad.addColorStop(0, "#ffe0bd");
        headGrad.addColorStop(1, "#ffcc99");
        ctx.fillStyle = headGrad;
        ctx.beginPath();
        ctx.arc(headX, headY, headRadius, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(headX - 7, headY - 5, 2, 0, Math.PI*2);
        ctx.arc(headX + 7, headY - 5, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(headX, headY, 10, 0.2*Math.PI, 0.8*Math.PI);
        ctx.stroke();
        // Draw hair above face.
        ctx.save();
        if(this.avatar === "Mona") {
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(headX - 22, headY - 18);
          ctx.quadraticCurveTo(headX, headY - 35, headX + 22, headY - 18);
          ctx.stroke();
        } else {
          ctx.fillStyle = "#8B4513";
          ctx.beginPath();
          ctx.arc(headX, headY - 10, 15, Math.PI, 0);
          ctx.fill();
        }
        ctx.restore();
        
        // Draw any panda in "beingCollected" state (drawn between body and backpack)
        targets.forEach(target => {
          if(target.type === "panda" && target.state === "beingCollected") {
            drawPanda(ctx, target.x, target.y, target.size/2, target.animationTime, target.gender);
          }
        });
        
        // Draw backpack on top. Apply jiggle if active.
        ctx.save();
        let bpOffset = 0;
        if(this.backpackJiggleTime > 0) {
          bpOffset = (Math.random()-0.5)*8;
        }
        ctx.translate(bpOffset, 0);
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(this.backpack.x, this.backpack.y, this.backpack.width, this.backpack.height);
        ctx.strokeStyle = "#000";
        ctx.strokeRect(this.backpack.x, this.backpack.y, this.backpack.width, this.backpack.height);
        ctx.beginPath();
        ctx.moveTo(this.backpack.x, this.backpack.y + 5);
        ctx.lineTo(this.x - this.width/2, this.y - this.height + 10);
        ctx.moveTo(this.backpack.x + this.backpack.width, this.backpack.y + 5);
        ctx.lineTo(this.x + this.width/2, this.y - this.height + 10);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(this.backpack.x + this.backpack.width/2, this.backpack.y, this.backpack.width * 0.4, this.backpack.height * 0.3, 0, 0, Math.PI*2);
        ctx.strokeStyle = "#fff";
        ctx.stroke();
        ctx.restore();
        ctx.restore();
      }
    }
    
    // ================== PROJECTILE CLASS ==================
    class Projectile {
      constructor(x, y, vx, vy) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = 6;
        this.trail = [];
      }
      update(deltaTime) {
        this.trail.push({ x: this.x, y: this.y, time: Date.now() });
        const now = Date.now();
        this.trail = this.trail.filter(p => now - p.time < 200);
        this.x += this.vx * deltaTime / 1000;
        this.y += this.vy * deltaTime / 1000;
      }
      draw(ctx) {
        ctx.save();
        for (let i = 0; i < this.trail.length; i++) {
          const t = this.trail[i];
          const alpha = (i + 1) / this.trail.length * 0.5;
          ctx.fillStyle = `rgba(255,69,0,${alpha})`;
          ctx.beginPath();
          ctx.arc(t.x, t.y, this.radius, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // ================== TARGET CLASS ==================
    class Target {
      constructor(type, x, y) {
        this.type = type; // "heart", "star", "panda"
        this.x = x;
        this.y = y;
        this.vy = levels[currentLevelIndex].scrollSpeed;
        this.hit = false;
        this.effectTime = 0;
        this.size = 60;
        if(this.type === "heart") {
          this.scoreValue = 15;
          this.label = randomHeartLabel();
        } else if(this.type === "star") {
          this.scoreValue = 20;
          this.label = randomStarLabel();
        } else if(this.type === "panda") {
          this.scoreValue = 25;
          this.gender = Math.random() < 0.5 ? "female" : "male";
          this.state = "free"; // "free", "beingCollected", "collected"
          this.animationTime = 0;
          this.collectionTimer = undefined;
        }
      }
      update(deltaTime) {
        if(this.type !== "panda" || this.state === "free") {
          this.y += this.vy * deltaTime / 1000;
        }
        if(this.hit) this.effectTime += deltaTime;
        if(this.type === "panda" && this.state === "free") {
          this.animationTime += deltaTime;
        }
        if(this.type === "panda" && this.state === "beingCollected") {
          if(this.collectionTimer === undefined) {
            this.collectionTimer = 0;
          } else {
            this.collectionTimer += deltaTime;
            const t = Math.min(this.collectionTimer / 500, 1);
            const targetY = player.backpack.y + player.backpack.height/2;
            this.y = (1-t)*(player.backpack.y - 20) + t*targetY;
            if(t >= 1) {
              this.state = "collected";
              addPointAnimation("+" + this.scoreValue, player.backpack.x + player.backpack.width/2, player.backpack.y);
              score = Math.max(0, score + this.scoreValue);
              addLogMessage(`${player.avatar} rescued a panda`);
              rescuedPandas.push({ x: player.backpack.x + player.backpack.width/2, y: player.backpack.y, size: this.size, time: 0, gender: this.gender });
              player.backpackJiggleTime = 500;
            }
          }
        }
      }
      draw(ctx) {
        ctx.save();
        const scale = getScaleForY(this.y);
        ctx.translate(this.x, this.y);
        ctx.scale(scale, scale);
        if(this.type === "heart") {
          const extra = this.hit ? this.effectTime / 500 : 0;
          ctx.globalAlpha = this.hit ? Math.max(1 - this.effectTime / 500, 0) : 1;
          drawHeart(ctx, 0, 0, this.size/2 + extra, this.label);
        } else if(this.type === "star") {
          const extra = this.hit ? this.effectTime / 300 : 0;
          ctx.globalAlpha = this.hit ? Math.max(1 - this.effectTime / 300, 0) : 1;
          drawStar(ctx, 0, 0, this.size/2 + extra, this.label);
        } else if(this.type === "panda") {
          if(this.state === "free" || this.state === "beingCollected") {
            drawPanda(ctx, 0, 0, this.size/2, this.animationTime, this.gender);
          }
        }
        ctx.restore();
      }
    }
    
    // ================== DRAW FUNCTIONS: HEART & STAR ==================
    function drawHeart(ctx, x, y, size, label) {
      ctx.save();
      ctx.translate(x, y);
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 4;
      ctx.beginPath();
      const topCurveHeight = size * 0.3;
      ctx.moveTo(0, topCurveHeight);
      ctx.bezierCurveTo(0, 0, -size, 0, -size, topCurveHeight);
      ctx.bezierCurveTo(-size, size, 0, size * 1.2, 0, size * 1.5);
      ctx.bezierCurveTo(0, size * 1.2, size, size, size, topCurveHeight);
      ctx.bezierCurveTo(size, 0, 0, 0, 0, topCurveHeight);
      ctx.closePath();
      const grad = ctx.createLinearGradient(-size, -size, size, size);
      grad.addColorStop(0, "#ff6699");
      grad.addColorStop(1, "#ff3366");
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = `${size * 0.4}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, 0, size * 0.6);
      ctx.restore();
    }
    
    function drawStar(ctx, x, y, size, label) {
      ctx.save();
      ctx.translate(x, y);
      ctx.shadowColor = "rgba(0,0,0,0.4)";
      ctx.shadowBlur = 4;
      ctx.beginPath();
      const spikes = 5;
      const outerRadius = size;
      const innerRadius = size * 0.5;
      let rot = Math.PI / 2 * 3;
      const step = Math.PI / spikes;
      ctx.moveTo(0, -outerRadius);
      for (let i = 0; i < spikes; i++) {
        const x1 = Math.cos(rot) * outerRadius;
        const y1 = Math.sin(rot) * outerRadius;
        ctx.lineTo(x1, y1);
        rot += step;
        const x2 = Math.cos(rot) * innerRadius;
        const y2 = Math.sin(rot) * innerRadius;
        ctx.lineTo(x2, y2);
        rot += step;
      }
      ctx.closePath();
      ctx.fillStyle = "#ffcc00";
      ctx.fill();
      ctx.fillStyle = "#000";
      ctx.font = `${size * 0.4}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, 0, 0);
      ctx.restore();
    }
    
    // ================== DRAW PANDA FUNCTION ==================
    function drawPanda(ctx, x, y, size, time, gender="male") {
      ctx.save();
      ctx.translate(x, y);
      // Body
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.ellipse(0, size * 0.2, size, size * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#000";
      ctx.stroke();
      // Head
      ctx.beginPath();
      ctx.arc(0, -size * 0.2, size * 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      // Eyes with highlights and blush.
      ctx.fillStyle = "#000";
      const eyeOffset = size * 0.2;
      ctx.beginPath();
      ctx.arc(-eyeOffset, -size * 0.2, size * 0.17, 0, Math.PI * 2);
      ctx.arc(eyeOffset, -size * 0.2, size * 0.17, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.beginPath();
      ctx.arc(-eyeOffset, -size * 0.2, size * 0.06, 0, Math.PI * 2);
      ctx.arc(eyeOffset, -size * 0.2, size * 0.06, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "rgba(255,0,0,0.3)";
      ctx.beginPath();
      ctx.arc(-eyeOffset, -size * 0.2, size * 0.1, 0, Math.PI * 2);
      ctx.arc(eyeOffset, -size * 0.2, size * 0.1, 0, Math.PI * 2);
      ctx.fill();
      // Nose and mouth
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(0, -size * 0.1, size * 0.08, 0, Math.PI, false);
      ctx.stroke();
      // Gender-specific adornments.
      if (gender === "female") {
        ctx.fillStyle = "#ff99cc";
        ctx.fillRect(-size * 0.6, -size * 0.35, size * 1.2, size * 0.1);
      } else {
        ctx.fillStyle = "#6699ff";
        ctx.beginPath();
        ctx.arc(0, -size * 0.4, size * 0.3, Math.PI, 0);
        ctx.fill();
      }
      // Limbs as circles.
      const limbOffset = Math.sin(time / 200) * size * 0.1;
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(-size * 0.7 + limbOffset, 0, size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(size * 0.7 - limbOffset, 0, size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(-size * 0.4 + limbOffset, size * 0.8, size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(size * 0.4 - limbOffset, size * 0.8, size * 0.15, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    // ================== OBSTACLE CLASS ==================
    class Obstacle {
      constructor(type, x, y) {
        this.type = type; // "car", "person", "bike", etc.
        this.x = x;
        this.y = y;
        this.vy = levels[currentLevelIndex].scrollSpeed;
        this.size = 60;
      }
      update(deltaTime) {
        this.y += this.vy * deltaTime / 1000;
      }
      draw(ctx) {
        ctx.save();
        const scale = getScaleForY(this.y);
        ctx.translate(this.x, this.y);
        ctx.scale(scale, scale);
        if (levels[currentLevelIndex].name === "City") {
          if (this.type === "car") {
            ctx.fillStyle = "#333";
            ctx.fillRect(-30, -10, 60, 30);
            ctx.fillStyle = "#999";
            ctx.fillRect(-20, -5, 40, 15);
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(-15, 25, 8, 0, Math.PI * 2);
            ctx.arc(15, 25, 8, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.type === "person") {
            ctx.fillStyle = "#ffe0bd";
            ctx.beginPath();
            ctx.arc(0, -20, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#ff6699";
            ctx.fillRect(-10, -8, 20, 30);
            ctx.strokeStyle = "#000";
            ctx.beginPath();
            ctx.moveTo(-10, 22);
            ctx.lineTo(-20, 40);
            ctx.moveTo(10, 22);
            ctx.lineTo(20, 40);
            ctx.stroke();
          } else if (this.type === "bike") {
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(-15, 10, 10, 0, Math.PI * 2);
            ctx.arc(15, 10, 10, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-15, 10);
            ctx.lineTo(0, -5);
            ctx.lineTo(15, 10);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, -5);
            ctx.lineTo(0, 10);
            ctx.stroke();
          }
        } else if (levels[currentLevelIndex].name === "Forest") {
          if (this.type === "stone") {
            ctx.fillStyle = "#888";
            ctx.beginPath();
            ctx.ellipse(0, 0, 25, 15, 0, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.type === "mouse") {
            ctx.fillStyle = "#aaa";
            ctx.beginPath();
            ctx.ellipse(0, 0, 20, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#888";
            ctx.beginPath();
            ctx.arc(-15, -10, 5, 0, Math.PI * 2);
            ctx.arc(15, -10, 5, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.type === "mushroom") {
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(0, 0, 15, Math.PI, 0);
            ctx.fill();
            ctx.fillStyle = "#ff6699";
            ctx.fillRect(-10, 0, 20, 15);
            ctx.strokeStyle = "#000";
            ctx.strokeRect(-10, 0, 20, 15);
          }
        } else if (levels[currentLevelIndex].name === "Space") {
          if (this.type === "planet") {
            const grad = ctx.createRadialGradient(0, 0, 10, 0, 0, 30);
            grad.addColorStop(0, "#66ccff");
            grad.addColorStop(1, "#003366");
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(0, 0, 30, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.type === "alien") {
            ctx.fillStyle = "#0f0";
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(-10, -5, 3, 0, Math.PI * 2);
            ctx.arc(10, -5, 3, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.type === "rocket") {
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(-10, 0);
            ctx.lineTo(10, 0);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = "#f00";
            ctx.fillRect(-5, 0, 10, 30);
          }
        }
        ctx.restore();
      }
    }
    
    // ================== PARTICLE CLASS ==================
    class Particle {
      constructor(x, y, vx, vy, life) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
        this.maxLife = life;
      }
      update(deltaTime) {
        this.x += this.vx * deltaTime / 1000;
        this.y += this.vy * deltaTime / 1000;
        this.life -= deltaTime;
      }
      draw(ctx) {
        if (this.life > 0) {
          const alpha = this.life / this.maxLife;
          ctx.fillStyle = `rgba(255,215,0,${alpha})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    // ================== DECORATION CLASS ==================
    class Decoration {
      constructor(type, x, y, levelName) {
        this.type = type;
        this.x = x;
        this.y = y;
        this.vy = levels[currentLevelIndex].scrollSpeed;
        this.size = 80;
        this.levelName = levelName;
      }
      update(deltaTime) {
        this.y += this.vy * deltaTime / 1000;
      }
      draw(ctx) {
        ctx.save();
        const scale = getScaleForY(this.y);
        ctx.translate(this.x, this.y);
        ctx.scale(scale, scale);
        if (this.levelName === "City") {
          if (this.type === "building") {
            ctx.fillStyle = "#777";
            ctx.fillRect(-20, -40, 40, 80);
            ctx.fillStyle = "#fff";
            for (let i = -30; i < 30; i += 10) {
              ctx.fillRect(i, -30, 5, 10);
            }
          } else if (this.type === "lamp") {
            ctx.strokeStyle = "#ffcc00";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, 20);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.stroke();
          }
        } else if (this.levelName === "Forest") {
          if (this.type === "tree") {
            ctx.fillStyle = "#8B4513";
            ctx.fillRect(-5, 0, 10, 30);
            ctx.fillStyle = "#228B22";
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
          } else if (this.type === "bush") {
            ctx.fillStyle = "#2E8B57";
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
          }
        } else if (this.levelName === "Space") {
          if (this.type === "satellite") {
            ctx.fillStyle = "#ccc";
            ctx.fillRect(-10, -10, 20, 20);
            ctx.strokeStyle = "#999";
            ctx.beginPath();
            ctx.moveTo(-15, -15);
            ctx.lineTo(15, 15);
            ctx.stroke();
          } else if (this.type === "comet") {
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = "#ffcc00";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(20, 20);
            ctx.stroke();
          }
        }
        ctx.restore();
      }
    }
    
    // ================== SKY ELEMENTS ==================
    class Cloud {
      constructor(x, y, speed, size) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.size = size;
      }
      update(deltaTime) {
        this.x += this.speed * deltaTime / 1000;
        if (this.x - this.size > canvas.width) this.x = -this.size;
      }
      draw(ctx) {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    class Bird {
      constructor(x, y, speed) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.wingTime = 0;
      }
      update(deltaTime) {
        this.x += this.speed * deltaTime / 1000;
        this.wingTime += deltaTime;
        if (this.x > canvas.width + 20) this.x = -20;
      }
      draw(ctx) {
        ctx.save();
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const wing = Math.sin(this.wingTime/200) * 5;
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x - 10, this.y - wing);
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + 10, this.y - wing);
        ctx.stroke();
        ctx.restore();
      }
    }
    
    class SpaceStar {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.alpha = Math.random();
      }
      update(deltaTime) {
        this.alpha += (Math.random()-0.5)*0.01;
        this.alpha = Math.max(0.3, Math.min(1, this.alpha));
      }
      draw(ctx) {
        ctx.save();
        ctx.fillStyle = `rgba(255,255,255,${this.alpha})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // ================== GAME LOOP ==================
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;
      if (!paused && gameState === "playing") {
        updateGame(deltaTime);
        drawGame();
        requestAnimationFrame(gameLoop);
      }
    }
    
    function updateGame(deltaTime) {
      if (gameState === "win") return;
      scrollOffset += levels[currentLevelIndex].scrollSpeed * deltaTime / 1000;
      player.update(deltaTime);
      if (levels[currentLevelIndex].name !== "Space") {
        clouds.forEach(cloud => cloud.update(deltaTime));
        birds.forEach(bird => bird.update(deltaTime));
      } else {
        spaceStars.forEach(star => star.update(deltaTime));
      }
      for (let i = projectiles.length - 1; i >= 0; i--) {
        projectiles[i].update(deltaTime);
        if (projectiles[i].x < 0 || projectiles[i].x > canvas.width ||
            projectiles[i].y < 0 || projectiles[i].y > canvas.height)
          projectiles.splice(i, 1);
      }
      for (let i = targets.length - 1; i >= 0; i--) {
        targets[i].update(deltaTime);
        if (targets[i].y - targets[i].size * getScaleForY(targets[i].y) > canvas.height ||
           (targets[i].hit && ((targets[i].type === "heart" && targets[i].effectTime > 500) ||
                               (targets[i].type === "star" && targets[i].effectTime > 300))))
          targets.splice(i, 1);
      }
      for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].update(deltaTime);
        if (obstacles[i].y > canvas.height) obstacles.splice(i, 1);
      }
      for (let i = decorations.length - 1; i >= 0; i--) {
        decorations[i].update(deltaTime);
        if (decorations[i].y > canvas.height) decorations.splice(i, 1);
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(deltaTime);
        if (particles[i].life <= 0) particles.splice(i, 1);
      }
      for (let i = pointAnimations.length - 1; i >= 0; i--) {
        pointAnimations[i].time += deltaTime;
        pointAnimations[i].y -= deltaTime * 0.03;
        if (pointAnimations[i].time > pointAnimations[i].lifetime)
          pointAnimations.splice(i, 1);
      }
      for (let i = logMessages.length - 1; i >= 0; i--) {
        logMessages[i].time += deltaTime;
        if (logMessages[i].time > logMessages[i].lifetime)
          logMessages.splice(i, 1);
      }
      rescuedPandas.forEach(p => p.time += deltaTime);
      
      // Projectile collisions (only hearts and stars; ignore pandas)
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];
        for (let j = 0; j < targets.length; j++) {
          const target = targets[j];
          if (target.type === "panda") continue;
          const dx = proj.x - target.x;
          const dy = proj.y - target.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < proj.radius + target.size/2 * getScaleForY(target.y)) {
            if (target.type === "heart" || target.type === "star") {
              if (!target.hit) {
                target.hit = true;
                addPointAnimation("+" + target.scoreValue, target.x, target.y);
                score += target.scoreValue;
                addLogMessage(`${player.avatar} collected ${target.label}`);
              }
            }
            projectiles.splice(i, 1);
            break;
          }
        }
      }
      
      // Player-body collision with hearts/stars
      targets.forEach(target => {
        if ((target.type === "heart" || target.type === "star") && !target.hit) {
          if (rectCircleColliding(player.x - player.width/2, player.y - player.height, player.width, player.height,
              target.x, target.y, target.size/2 * getScaleForY(target.y))) {
            target.hit = true;
            addPointAnimation("+" + target.scoreValue, target.x, target.y);
            score += target.scoreValue;
            addLogMessage(`${player.avatar} collected ${target.label}`);
          }
        }
      });
      
      // Panda rescue: dragging a panda into the backpack.
      targets.forEach(target => {
        if (target.type === "panda" && target.state === "free") {
          const bp = player.backpack;
          if (target.x > bp.x && target.x < bp.x + bp.width &&
              target.y > bp.y && target.y < bp.y + bp.height) {
            target.state = "beingCollected";
            target.collectionTimer = undefined;
          }
        }
      });
      
      // Obstacle collision (body only)
      obstacles.forEach((obs, index) => {
        if (rectCircleColliding(player.x - player.width/2, player.y - player.height, player.width, player.height,
              obs.x + obs.size/2, obs.y + obs.size/2, obs.size/2 * getScaleForY(obs.y))) {
          score = Math.max(0, score - 5);
          addPointAnimation("-5", player.x, player.y);
          addLogMessage(`${player.avatar} hit an obstacle`);
          playerShakeTime = 500;
          obstacles.splice(index, 1);
        }
      });
      
      // Projectiles remove obstacles (no points)
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const proj = projectiles[i];
        for (let j = obstacles.length - 1; j >= 0; j--) {
          const obs = obstacles[j];
          const dx = proj.x - obs.x;
          const dy = proj.y - obs.y;
          const dist = Math.sqrt(dx*dx+dy*dy);
          if (dist < proj.radius + obs.size/2 * getScaleForY(obs.y)) {
            obstacles.splice(j, 1);
            projectiles.splice(i, 1);
            break;
          }
        }
      }
      
      // Spawn new objects every 1 second.
      spawnTimer += deltaTime;
      if (spawnTimer > 1000) {
        const groundStart = canvas.height * 0.2;
        const spawnY = groundStart + 20;
        const r = Math.random();
        if (r < 0.4) {
          targets.push(new Target(Math.random() < 0.5 ? "heart" : "star", Math.random() * canvas.width, spawnY));
        } else if (r < 0.7) {
          targets.push(new Target("panda", Math.random() * canvas.width, spawnY));
        } else if (r < 0.8) {
          let obsType;
          if (levels[currentLevelIndex].name === "City") {
            const r2 = Math.random();
            obsType = r2 < 0.33 ? "car" : (r2 < 0.66 ? "person" : "bike");
          } else if (levels[currentLevelIndex].name === "Forest") {
            const r2 = Math.random();
            obsType = r2 < 0.33 ? "stone" : (r2 < 0.66 ? "mouse" : "mushroom");
          } else if (levels[currentLevelIndex].name === "Space") {
            const r2 = Math.random();
            obsType = r2 < 0.33 ? "planet" : (r2 < 0.66 ? "alien" : "rocket");
          }
          obstacles.push(new Obstacle(obsType, Math.random() * (canvas.width - 80) + 40, spawnY));
        } else {
          const sideX = Math.random() < 0.5 ? Math.random() * 50 + 10 : canvas.width - (Math.random() * 50 + 10);
          decorations.push(levels[currentLevelIndex].createDecoration(sideX, spawnY));
        }
        spawnTimer = 0;
      }
      
      // Level progression.
      if (score >= levelThresholds[currentLevelIndex]) {
        if (currentLevelIndex < levels.length - 1) {
          currentLevelIndex++;
          targets = [];
          obstacles = [];
          decorations = [];
          scrollOffset = 0;
          if (levels[currentLevelIndex].name !== "Space") {
            clouds = [];
            birds = [];
            for (let i = 0; i < 5; i++) {
              clouds.push(new Cloud(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 10 + Math.random()*10, 30 + Math.random()*20));
            }
            for (let i = 0; i < 3; i++) {
              birds.push(new Bird(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 50 + Math.random()*30));
            }
          } else {
            spaceStars = [];
            for (let i = 0; i < 50; i++) {
              spaceStars.push(new SpaceStar(Math.random()*canvas.width, Math.random()*canvas.height*0.2));
            }
          }
        } else {
          gameState = "win";
          showWinScreen();
          return;
        }
      }
    }
    
    function drawGame() {
      if (gameState === "win") return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const skyHeight = canvas.height * 0.2;
      ctx.fillStyle = levels[currentLevelIndex].skyColor;
      ctx.fillRect(0, 0, canvas.width, skyHeight);
      if (levels[currentLevelIndex].name !== "Space") {
        clouds.forEach(cloud => cloud.draw(ctx));
        birds.forEach(bird => bird.draw(ctx));
      } else {
        spaceStars.forEach(star => star.draw(ctx));
      }
      if (logMessages.length > 0) {
        ctx.save();
        ctx.font = "20px sans-serif";
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.textAlign = "center";
        ctx.fillText(logMessages[0].text, canvas.width/2, 40);
        ctx.restore();
      }
      ctx.save();
      ctx.translate(0, skyHeight + (scrollOffset % 50));
      ctx.fillStyle = levels[currentLevelIndex].groundPattern;
      ctx.fillRect(0, 0, canvas.width, canvas.height - skyHeight);
      ctx.restore();
      decorations.forEach(dec => dec.draw(ctx));
      obstacles.forEach(obs => obs.draw(ctx));
      targets.forEach(target => {
        // Do not draw pandas in "beingCollected" state (they're drawn by player)
        if (!(target.type === "panda" && target.state === "beingCollected"))
          target.draw(ctx);
      });
      projectiles.forEach(proj => proj.draw(ctx));
      particles.forEach(p => p.draw(ctx));
      ctx.save();
      ctx.font = "20px sans-serif";
      ctx.textAlign = "center";
      pointAnimations.forEach(pa => {
        ctx.fillStyle = "rgba(0,128,0," + (1 - pa.time/pa.lifetime) + ")";
        ctx.fillText(pa.text, pa.x, pa.y);
      });
      ctx.restore();
      player.draw(ctx);
      ctx.save();
      ctx.font = "24px sans-serif";
      ctx.fillStyle = "#333";
      ctx.textAlign = "right";
      ctx.fillText("Score: " + score, canvas.width - 20, 40);
      const progressBarWidth = Math.max(100, canvas.width * 0.5);
      const progress = (score - (currentLevelIndex === 0 ? 0 : levelThresholds[currentLevelIndex-1])) /
                         (levelThresholds[currentLevelIndex] - (currentLevelIndex === 0 ? 0 : levelThresholds[currentLevelIndex-1]));
      const barX = canvas.width - progressBarWidth - 20;
      const barY = 50;
      const barHeight = 20;
      const grad = ctx.createLinearGradient(barX, barY, barX, barY + barHeight);
      grad.addColorStop(0, "#ff99a0");
      grad.addColorStop(1, "#ff3366");
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 2;
      drawRoundedRect(ctx, barX, barY, progressBarWidth, barHeight, 10);
      ctx.stroke();
      ctx.save();
      ctx.beginPath();
      drawRoundedRect(ctx, barX, barY, progressBarWidth * progress, barHeight, 10);
      ctx.clip();
      ctx.fillStyle = grad;
      ctx.fillRect(barX, barY, progressBarWidth * progress, barHeight);
      ctx.restore();
      ctx.fillStyle = "#333";
      ctx.fillText(`Level ${currentLevelIndex+1} / ${levels.length}`, canvas.width - 20, barY + barHeight + 30);
      draw3DButton(ctx, 20, 20, 80, 30, "Menu");
      ctx.restore();
    }
    
    function draw3DButton(ctx, x, y, width, height, text) {
      ctx.save();
      const grad = ctx.createLinearGradient(x, y, x, y + height);
      grad.addColorStop(0, "#ffccdd");
      grad.addColorStop(1, "#ff6699");
      ctx.fillStyle = grad;
      ctx.shadowColor = "rgba(0,0,0,0.3)";
      ctx.shadowBlur = 4;
      drawRoundedRect(ctx, x, y, width, height, 8);
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      drawRoundedRect(ctx, x, y, width, height, 8);
      ctx.stroke();
      ctx.fillStyle = "#fff";
      ctx.font = "16px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, x + width/2, y + height/2);
      ctx.restore();
    }
    
    function rectCircleColliding(rx, ry, rw, rh, cx, cy, cr) {
      const closestX = Math.clamp(cx, rx, rx + rw);
      const closestY = Math.clamp(cy, ry, ry + rh);
      const dx = cx - closestX;
      const dy = cy - closestY;
      return (dx * dx + dy * dy) < (cr * cr);
    }
    
    // ================== INPUT HANDLERS ==================
    // Variables isDraggingPlayer, dragOffsetX, draggingPanda have been declared above.
    function input_getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches && e.touches.length > 0) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      return { x, y };
    }
    function input_pointerDown(e) {
      if (gameState !== "playing") return;
      const pos = input_getPointerPos(e);
      if (pos.x >= 20 && pos.x <= 100 && pos.y >= 20 && pos.y <= 50) {
        pauseGame();
        return;
      }
      if (draggingPanda) return;
      if (pos.x > player.x - player.width && pos.x < player.x + player.width &&
          pos.y > player.y - player.height - 50 && pos.y < player.y) {
        isDraggingPlayer = true;
        dragOffsetX = pos.x - player.x;
        e.preventDefault();
        return;
      }
      for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        if (target.type === "panda" && target.state === "free") {
          const dx = pos.x - target.x;
          const dy = pos.y - target.y;
          if (Math.sqrt(dx*dx + dy*dy) < target.size/2) {
            draggingPanda = target;
            e.preventDefault();
            return;
          }
        }
      }
      shootProjectile(pos);
    }
    function input_pointerMove(e) {
      if (gameState !== "playing") return;
      const pos = input_getPointerPos(e);
      if (isDraggingPlayer) {
        player.x = pos.x - dragOffsetX;
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
      }
      if (draggingPanda) {
        draggingPanda.x = pos.x;
        draggingPanda.y = pos.y;
      }
    }
    function input_pointerUp(e) {
      if (gameState !== "playing") return;
      isDraggingPlayer = false;
      draggingPanda = null;
    }
    function shootProjectile(pos) {
      const dx = pos.x - player.x;
      const dy = pos.y - (player.y - player.height/2);
      const mag = Math.sqrt(dx*dx + dy*dy);
      const speed = 500;
      const vx = (dx/mag) * speed;
      const vy = (dy/mag) * speed;
      projectiles.push(new Projectile(player.x, player.y - player.height/2, vx, vy));
    }
    canvas.addEventListener("mousedown", input_pointerDown);
    canvas.addEventListener("touchstart", input_pointerDown);
    canvas.addEventListener("mousemove", input_pointerMove);
    canvas.addEventListener("touchmove", input_pointerMove);
    canvas.addEventListener("mouseup", input_pointerUp);
    canvas.addEventListener("touchend", input_pointerUp);
    
    // ================== MENU FUNCTIONS ==================
    function selectAvatar(avatar) {
      selectedAvatar = avatar;
      const exp = document.querySelector("#menuOverlay p.explanation");
      exp.innerHTML = exp.innerHTML.replace(/Selected: .*/,"") + `<br><br>Selected: ${avatar}`;
      document.getElementById("btnMona").classList.toggle("selected", avatar === "Mona");
      document.getElementById("btnJonas").classList.toggle("selected", avatar === "Jonas");
    }
    function startGame() {
      document.getElementById("menuOverlay").style.display = "none";
      gameState = "playing";
      player = new Player(selectedAvatar || "Mona");
      projectiles = [];
      targets = [];
      obstacles = [];
      decorations = [];
      clouds = [];
      birds = [];
      spaceStars = [];
      particles = [];
      pointAnimations = [];
      logMessages = [];
      rescuedPandas = [];
      scrollOffset = 0;
      score = 0;
      lastTime = 0;
      spawnTimer = 0;
      currentLevelIndex = 0;
      if (levels[currentLevelIndex].name !== "Space") {
        for (let i = 0; i < 5; i++) {
          clouds.push(new Cloud(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 10 + Math.random()*10, 30 + Math.random()*20));
        }
        for (let i = 0; i < 3; i++) {
          birds.push(new Bird(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 50 + Math.random()*30));
        }
      } else {
        for (let i = 0; i < 50; i++) {
          spaceStars.push(new SpaceStar(Math.random()*canvas.width, Math.random()*canvas.height*0.2));
        }
      }
      requestAnimationFrame(gameLoop);
    }
    function pauseGame() {
      paused = true;
      gameState = "paused";
      document.getElementById("pauseOverlay").style.display = "flex";
    }
    function resumeGame() {
      paused = false;
      gameState = "playing";
      document.getElementById("pauseOverlay").style.display = "none";
      requestAnimationFrame(gameLoop);
    }
    function changeAvatar() {
      paused = false;
      gameState = "menu";
      document.getElementById("pauseOverlay").style.display = "none";
      document.getElementById("menuOverlay").style.display = "flex";
    }
    
    // ================== WIN SCREEN FUNCTIONS ==================
    function showWinScreen() {
      document.getElementById("winOverlay").style.display = "flex";
      document.getElementById("stats").innerHTML = `Score: ${score}<br>Pandas Rescued: ${rescuedPandas.length}`;
      winDancingPandas = [];
      for (let i = 0; i < 5; i++) {
        winDancingPandas.push({
          x: Math.random() * canvas.width,
          y: Math.random() * (canvas.height * 0.5) + canvas.height * 0.3,
          dx: (Math.random()-0.5)*2,
          dy: (Math.random()-0.5)*2,
          time: 0,
          gender: Math.random() < 0.5 ? "female" : "male"
        });
      }
      winFallingTargets = [];
      for (let i = 0; i < 15; i++) {
        winFallingTargets.push(new WinFallingItem());
      }
      globalLastWinTime = 0;
      requestAnimationFrame(winAnimLoop);
    }
    class WinFallingItem {
      constructor() {
        this.type = Math.random() < 0.5 ? "heart" : "star";
        this.label = this.type === "heart" ? randomHeartLabel() : randomStarLabel();
        this.scoreValue = this.type === "heart" ? 15 : 20;
        this.x = Math.random() * canvas.width;
        this.y = -50;
        this.vy = 50 + Math.random()*30;
        this.alpha = 1;
      }
      update(deltaTime) {
        this.y += this.vy * deltaTime / 1000;
        this.alpha -= deltaTime / 30000;
      }
      draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        if (this.type === "heart") {
          drawHeart(ctx, this.x, this.y, 30, this.label);
        } else {
          drawStar(ctx, this.x, this.y, 30, this.label);
        }
        ctx.restore();
      }
    }
    function winAnimLoop(timestamp) {
      if (!globalLastWinTime) globalLastWinTime = timestamp;
      const deltaTime = timestamp - globalLastWinTime;
      globalLastWinTime = timestamp;
      winDancingPandas.forEach(panda => {
        panda.x += panda.dx;
        panda.y += panda.dy;
        if (panda.x < 0 || panda.x > canvas.width) panda.dx *= -1;
        if (panda.y < 0 || panda.y > canvas.height) panda.dy *= -1;
        panda.time += deltaTime;
      });
      winFallingTargets.forEach(item => item.update(deltaTime));
      const winAnimCanvas = document.getElementById("winAnim");
      const winCtx = winAnimCanvas.getContext("2d");
      winCtx.clearRect(0, 0, winAnimCanvas.width, winAnimCanvas.height);
      winFallingTargets.forEach(item => item.draw(winCtx));
      winDancingPandas.forEach(panda => {
        drawPanda(winCtx, panda.x, panda.y, 40, panda.time, panda.gender);
      });
      if (winFallingTargets.some(item => item.alpha > 0)) {
        requestAnimationFrame(winAnimLoop);
      }
    }
    
    // ================== MENU ANIMATION (Start Screen) ==================
    function updateMenuAnimation(dt) {
      menuAnimTime += dt;
    }
    function drawMenuAnimation() {
      menuAnimCtx.clearRect(0, 0, menuAnimCanvas.width, menuAnimCanvas.height);
      const tempPlayer = new Player(selectedAvatar || "Mona");
      tempPlayer.x = menuAnimCanvas.width / 2;
      tempPlayer.y = menuAnimCanvas.height / 2 + 20;
      tempPlayer.walkTime = menuAnimTime;
      tempPlayer.update(0);
      tempPlayer.draw(menuAnimCtx);
      menuAnimCtx.save();
      menuAnimCtx.translate(60 + Math.sin(menuAnimTime/500)*5, menuAnimCanvas.height/2);
      drawPanda(menuAnimCtx, 0, 0, 40, menuAnimTime, "female");
      menuAnimCtx.restore();
      menuAnimCtx.save();
      menuAnimCtx.translate(menuAnimCanvas.width - 60 + Math.sin(menuAnimTime/500)*5, menuAnimCanvas.height/2);
      drawPanda(menuAnimCtx, 0, 0, 40, menuAnimTime, "male");
      menuAnimCtx.restore();
    }
    function menuAnimationLoop(timestamp) {
      const dt = timestamp - (menuAnimTime || timestamp);
      updateMenuAnimation(dt);
      drawMenuAnimation();
      requestAnimationFrame(menuAnimationLoop);
    }
    requestAnimationFrame(menuAnimationLoop);
    
    // ================== INPUT HANDLERS ==================
    function input_getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches && e.touches.length > 0) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      return { x, y };
    }
    function input_pointerDown(e) {
      if (gameState !== "playing") return;
      const pos = input_getPointerPos(e);
      if (pos.x >= 20 && pos.x <= 100 && pos.y >= 20 && pos.y <= 50) {
        pauseGame();
        return;
      }
      if (draggingPanda) return;
      if (pos.x > player.x - player.width && pos.x < player.x + player.width &&
          pos.y > player.y - player.height - 50 && pos.y < player.y) {
        isDraggingPlayer = true;
        dragOffsetX = pos.x - player.x;
        e.preventDefault();
        return;
      }
      for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        if (target.type === "panda" && target.state === "free") {
          const dx = pos.x - target.x;
          const dy = pos.y - target.y;
          if (Math.sqrt(dx*dx+dy*dy) < target.size/2) {
            draggingPanda = target;
            e.preventDefault();
            return;
          }
        }
      }
      shootProjectile(pos);
    }
    function input_pointerMove(e) {
      if (gameState !== "playing") return;
      const pos = input_getPointerPos(e);
      if (isDraggingPlayer) {
        player.x = pos.x - dragOffsetX;
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
      }
      if (draggingPanda) {
        draggingPanda.x = pos.x;
        draggingPanda.y = pos.y;
      }
    }
    function input_pointerUp(e) {
      if (gameState !== "playing") return;
      isDraggingPlayer = false;
      draggingPanda = null;
    }
    function shootProjectile(pos) {
      const dx = pos.x - player.x;
      const dy = pos.y - (player.y - player.height/2);
      const mag = Math.sqrt(dx*dx + dy*dy);
      const speed = 500;
      const vx = (dx/mag) * speed;
      const vy = (dy/mag) * speed;
      projectiles.push(new Projectile(player.x, player.y - player.height/2, vx, vy));
    }
    canvas.addEventListener("mousedown", input_pointerDown);
    canvas.addEventListener("touchstart", input_pointerDown);
    canvas.addEventListener("mousemove", input_pointerMove);
    canvas.addEventListener("touchmove", input_pointerMove);
    canvas.addEventListener("mouseup", input_pointerUp);
    canvas.addEventListener("touchend", input_pointerUp);
    
    // ================== MENU FUNCTIONS ==================
    function selectAvatar(avatar) {
      selectedAvatar = avatar;
      const exp = document.querySelector("#menuOverlay p.explanation");
      exp.innerHTML = exp.innerHTML.replace(/Selected: .*/,"") + `<br><br>Selected: ${avatar}`;
      document.getElementById("btnMona").classList.toggle("selected", avatar === "Mona");
      document.getElementById("btnJonas").classList.toggle("selected", avatar === "Jonas");
    }
    function startGame() {
      document.getElementById("menuOverlay").style.display = "none";
      gameState = "playing";
      player = new Player(selectedAvatar || "Mona");
      projectiles = [];
      targets = [];
      obstacles = [];
      decorations = [];
      clouds = [];
      birds = [];
      spaceStars = [];
      particles = [];
      pointAnimations = [];
      logMessages = [];
      rescuedPandas = [];
      scrollOffset = 0;
      score = 0;
      lastTime = 0;
      spawnTimer = 0;
      currentLevelIndex = 0;
      if (levels[currentLevelIndex].name !== "Space") {
        for (let i = 0; i < 5; i++) {
          clouds.push(new Cloud(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 10 + Math.random()*10, 30 + Math.random()*20));
        }
        for (let i = 0; i < 3; i++) {
          birds.push(new Bird(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 50 + Math.random()*30));
        }
      } else {
        for (let i = 0; i < 50; i++) {
          spaceStars.push(new SpaceStar(Math.random()*canvas.width, Math.random()*canvas.height*0.2));
        }
      }
      requestAnimationFrame(gameLoop);
    }
    function pauseGame() {
      paused = true;
      gameState = "paused";
      document.getElementById("pauseOverlay").style.display = "flex";
    }
    function resumeGame() {
      paused = false;
      gameState = "playing";
      document.getElementById("pauseOverlay").style.display = "none";
      requestAnimationFrame(gameLoop);
    }
    function changeAvatar() {
      paused = false;
      gameState = "menu";
      document.getElementById("pauseOverlay").style.display = "none";
      document.getElementById("menuOverlay").style.display = "flex";
    }
    
    // ================== WIN SCREEN FUNCTIONS ==================
    function showWinScreen() {
      document.getElementById("winOverlay").style.display = "flex";
      document.getElementById("stats").innerHTML = `Score: ${score}<br>Pandas Rescued: ${rescuedPandas.length}`;
      winDancingPandas = [];
      for (let i = 0; i < 5; i++) {
        winDancingPandas.push({
          x: Math.random() * canvas.width,
          y: Math.random() * (canvas.height * 0.5) + canvas.height * 0.3,
          dx: (Math.random()-0.5)*2,
          dy: (Math.random()-0.5)*2,
          time: 0,
          gender: Math.random() < 0.5 ? "female" : "male"
        });
      }
      winFallingTargets = [];
      for (let i = 0; i < 15; i++) {
        winFallingTargets.push(new WinFallingItem());
      }
      globalLastWinTime = 0;
      requestAnimationFrame(winAnimLoop);
    }
    function winAnimLoop(timestamp) {
      if (!globalLastWinTime) globalLastWinTime = timestamp;
      const deltaTime = timestamp - globalLastWinTime;
      globalLastWinTime = timestamp;
      winDancingPandas.forEach(panda => {
        panda.x += panda.dx;
        panda.y += panda.dy;
        if (panda.x < 0 || panda.x > canvas.width) panda.dx *= -1;
        if (panda.y < 0 || panda.y > canvas.height) panda.dy *= -1;
        panda.time += deltaTime;
      });
      winFallingTargets.forEach(item => item.update(deltaTime));
      const winAnimCanvas = document.getElementById("winAnim");
      const winCtx = winAnimCanvas.getContext("2d");
      winCtx.clearRect(0, 0, winAnimCanvas.width, winAnimCanvas.height);
      winFallingTargets.forEach(item => item.draw(winCtx));
      winDancingPandas.forEach(panda => {
        drawPanda(winCtx, panda.x, panda.y, 40, panda.time, panda.gender);
      });
      if (winFallingTargets.some(item => item.alpha > 0)) {
        requestAnimationFrame(winAnimLoop);
      }
    }
    
    // ================== MENU ANIMATION (Start Screen) ==================
    function updateMenuAnimation(dt) {
      menuAnimTime += dt;
    }
    function drawMenuAnimation() {
      menuAnimCtx.clearRect(0, 0, menuAnimCanvas.width, menuAnimCanvas.height);
      const tempPlayer = new Player(selectedAvatar || "Mona");
      tempPlayer.x = menuAnimCanvas.width / 2;
      tempPlayer.y = menuAnimCanvas.height / 2 + 20;
      tempPlayer.walkTime = menuAnimTime;
      tempPlayer.update(0);
      tempPlayer.draw(menuAnimCtx);
      menuAnimCtx.save();
      menuAnimCtx.translate(60 + Math.sin(menuAnimTime/500)*5, menuAnimCanvas.height/2);
      drawPanda(menuAnimCtx, 0, 0, 40, menuAnimTime, "female");
      menuAnimCtx.restore();
      menuAnimCtx.save();
      menuAnimCtx.translate(menuAnimCanvas.width - 60 + Math.sin(menuAnimTime/500)*5, menuAnimCanvas.height/2);
      drawPanda(menuAnimCtx, 0, 0, 40, menuAnimTime, "male");
      menuAnimCtx.restore();
    }
    function menuAnimationLoop(timestamp) {
      const dt = timestamp - (menuAnimTime || timestamp);
      updateMenuAnimation(dt);
      drawMenuAnimation();
      requestAnimationFrame(menuAnimationLoop);
    }
    requestAnimationFrame(menuAnimationLoop);
    
    // ================== INPUT HANDLERS ==================
    // (The variables isDraggingPlayer, dragOffsetX, and draggingPanda are declared once above.)
    function input_getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches && e.touches.length > 0) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      return { x, y };
    }
    function input_pointerDown(e) {
      if (gameState !== "playing") return;
      const pos = input_getPointerPos(e);
      if (pos.x >= 20 && pos.x <= 100 && pos.y >= 20 && pos.y <= 50) {
        pauseGame();
        return;
      }
      if (draggingPanda) return;
      if (pos.x > player.x - player.width && pos.x < player.x + player.width &&
          pos.y > player.y - player.height - 50 && pos.y < player.y) {
        isDraggingPlayer = true;
        dragOffsetX = pos.x - player.x;
        e.preventDefault();
        return;
      }
      for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        if (target.type === "panda" && target.state === "free") {
          const dx = pos.x - target.x;
          const dy = pos.y - target.y;
          if (Math.sqrt(dx*dx+dy*dy) < target.size/2) {
            draggingPanda = target;
            e.preventDefault();
            return;
          }
        }
      }
      shootProjectile(pos);
    }
    function input_pointerMove(e) {
      if (gameState !== "playing") return;
      const pos = input_getPointerPos(e);
      if (isDraggingPlayer) {
        player.x = pos.x - dragOffsetX;
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
      }
      if (draggingPanda) {
        draggingPanda.x = pos.x;
        draggingPanda.y = pos.y;
      }
    }
    function input_pointerUp(e) {
      if (gameState !== "playing") return;
      isDraggingPlayer = false;
      draggingPanda = null;
    }
    function shootProjectile(pos) {
      const dx = pos.x - player.x;
      const dy = pos.y - (player.y - player.height/2);
      const mag = Math.sqrt(dx*dx + dy*dy);
      const speed = 500;
      const vx = (dx/mag) * speed;
      const vy = (dy/mag) * speed;
      projectiles.push(new Projectile(player.x, player.y - player.height/2, vx, vy));
    }
    canvas.addEventListener("mousedown", input_pointerDown);
    canvas.addEventListener("touchstart", input_pointerDown);
    canvas.addEventListener("mousemove", input_pointerMove);
    canvas.addEventListener("touchmove", input_pointerMove);
    canvas.addEventListener("mouseup", input_pointerUp);
    canvas.addEventListener("touchend", input_pointerUp);
    
    // ================== MENU FUNCTIONS ==================
    function selectAvatar(avatar) {
      selectedAvatar = avatar;
      const exp = document.querySelector("#menuOverlay p.explanation");
      exp.innerHTML = exp.innerHTML.replace(/Selected: .*/,"") + `<br><br>Selected: ${avatar}`;
      document.getElementById("btnMona").classList.toggle("selected", avatar === "Mona");
      document.getElementById("btnJonas").classList.toggle("selected", avatar === "Jonas");
    }
    function startGame() {
      document.getElementById("menuOverlay").style.display = "none";
      gameState = "playing";
      player = new Player(selectedAvatar || "Mona");
      projectiles = [];
      targets = [];
      obstacles = [];
      decorations = [];
      clouds = [];
      birds = [];
      spaceStars = [];
      particles = [];
      pointAnimations = [];
      logMessages = [];
      rescuedPandas = [];
      scrollOffset = 0;
      score = 0;
      lastTime = 0;
      spawnTimer = 0;
      currentLevelIndex = 0;
      if (levels[currentLevelIndex].name !== "Space") {
        for (let i = 0; i < 5; i++) {
          clouds.push(new Cloud(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 10 + Math.random()*10, 30 + Math.random()*20));
        }
        for (let i = 0; i < 3; i++) {
          birds.push(new Bird(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 50 + Math.random()*30));
        }
      } else {
        for (let i = 0; i < 50; i++) {
          spaceStars.push(new SpaceStar(Math.random()*canvas.width, Math.random()*canvas.height*0.2));
        }
      }
      requestAnimationFrame(gameLoop);
    }
    function pauseGame() {
      paused = true;
      gameState = "paused";
      document.getElementById("pauseOverlay").style.display = "flex";
    }
    function resumeGame() {
      paused = false;
      gameState = "playing";
      document.getElementById("pauseOverlay").style.display = "none";
      requestAnimationFrame(gameLoop);
    }
    function changeAvatar() {
      paused = false;
      gameState = "menu";
      document.getElementById("pauseOverlay").style.display = "none";
      document.getElementById("menuOverlay").style.display = "flex";
    }
    
    // ================== WIN SCREEN FUNCTIONS ==================
    function showWinScreen() {
      document.getElementById("winOverlay").style.display = "flex";
      document.getElementById("stats").innerHTML = `Score: ${score}<br>Pandas Rescued: ${rescuedPandas.length}`;
      winDancingPandas = [];
      for (let i = 0; i < 5; i++) {
        winDancingPandas.push({
          x: Math.random() * canvas.width,
          y: Math.random() * (canvas.height * 0.5) + canvas.height * 0.3,
          dx: (Math.random()-0.5)*2,
          dy: (Math.random()-0.5)*2,
          time: 0,
          gender: Math.random() < 0.5 ? "female" : "male"
        });
      }
      winFallingTargets = [];
      for (let i = 0; i < 15; i++) {
        winFallingTargets.push(new WinFallingItem());
      }
      globalLastWinTime = 0;
      requestAnimationFrame(winAnimLoop);
    }
    function winAnimLoop(timestamp) {
      if (!globalLastWinTime) globalLastWinTime = timestamp;
      const deltaTime = timestamp - globalLastWinTime;
      globalLastWinTime = timestamp;
      winDancingPandas.forEach(panda => {
        panda.x += panda.dx;
        panda.y += panda.dy;
        if (panda.x < 0 || panda.x > canvas.width) panda.dx *= -1;
        if (panda.y < 0 || panda.y > canvas.height) panda.dy *= -1;
        panda.time += deltaTime;
      });
      winFallingTargets.forEach(item => item.update(deltaTime));
      const winAnimCanvas = document.getElementById("winAnim");
      const winCtx = winAnimCanvas.getContext("2d");
      winCtx.clearRect(0, 0, winAnimCanvas.width, winAnimCanvas.height);
      winFallingTargets.forEach(item => item.draw(winCtx));
      winDancingPandas.forEach(panda => {
        drawPanda(winCtx, panda.x, panda.y, 40, panda.time, panda.gender);
      });
      if (winFallingTargets.some(item => item.alpha > 0)) {
        requestAnimationFrame(winAnimLoop);
      }
    }
    
    // ================== MENU ANIMATION (Start Screen) ==================
    function updateMenuAnimation(dt) {
      menuAnimTime += dt;
    }
    function drawMenuAnimation() {
      menuAnimCtx.clearRect(0, 0, menuAnimCanvas.width, menuAnimCanvas.height);
      const tempPlayer = new Player(selectedAvatar || "Mona");
      tempPlayer.x = menuAnimCanvas.width / 2;
      tempPlayer.y = menuAnimCanvas.height / 2 + 20;
      tempPlayer.walkTime = menuAnimTime;
      tempPlayer.update(0);
      tempPlayer.draw(menuAnimCtx);
      menuAnimCtx.save();
      menuAnimCtx.translate(60 + Math.sin(menuAnimTime/500)*5, menuAnimCanvas.height/2);
      drawPanda(menuAnimCtx, 0, 0, 40, menuAnimTime, "female");
      menuAnimCtx.restore();
      menuAnimCtx.save();
      menuAnimCtx.translate(menuAnimCanvas.width - 60 + Math.sin(menuAnimTime/500)*5, menuAnimCanvas.height/2);
      drawPanda(menuAnimCtx, 0, 0, 40, menuAnimTime, "male");
      menuAnimCtx.restore();
    }
    function menuAnimationLoop(timestamp) {
      const dt = timestamp - (menuAnimTime || timestamp);
      updateMenuAnimation(dt);
      drawMenuAnimation();
      requestAnimationFrame(menuAnimationLoop);
    }
    requestAnimationFrame(menuAnimationLoop);
    
    // ================== INPUT HANDLERS ==================
    function input_getPointerPos(e) {
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches && e.touches.length > 0) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      return { x, y };
    }
    function input_pointerDown(e) {
      if (gameState !== "playing") return;
      const pos = input_getPointerPos(e);
      if (pos.x >= 20 && pos.x <= 100 && pos.y >= 20 && pos.y <= 50) {
        pauseGame();
        return;
      }
      if (draggingPanda) return;
      if (pos.x > player.x - player.width && pos.x < player.x + player.width &&
          pos.y > player.y - player.height - 50 && pos.y < player.y) {
        isDraggingPlayer = true;
        dragOffsetX = pos.x - player.x;
        e.preventDefault();
        return;
      }
      for (let i = 0; i < targets.length; i++) {
        const target = targets[i];
        if (target.type === "panda" && target.state === "free") {
          const dx = pos.x - target.x;
          const dy = pos.y - target.y;
          if (Math.sqrt(dx*dx + dy*dy) < target.size/2) {
            draggingPanda = target;
            e.preventDefault();
            return;
          }
        }
      }
      shootProjectile(pos);
    }
    function input_pointerMove(e) {
      if (gameState !== "playing") return;
      const pos = input_getPointerPos(e);
      if (isDraggingPlayer) {
        player.x = pos.x - dragOffsetX;
        player.x = Math.max(player.width/2, Math.min(canvas.width - player.width/2, player.x));
      }
      if (draggingPanda) {
        draggingPanda.x = pos.x;
        draggingPanda.y = pos.y;
      }
    }
    function input_pointerUp(e) {
      if (gameState !== "playing") return;
      isDraggingPlayer = false;
      draggingPanda = null;
    }
    function shootProjectile(pos) {
      const dx = pos.x - player.x;
      const dy = pos.y - (player.y - player.height/2);
      const mag = Math.sqrt(dx*dx + dy*dy);
      const speed = 500;
      const vx = (dx/mag) * speed;
      const vy = (dy/mag) * speed;
      projectiles.push(new Projectile(player.x, player.y - player.height/2, vx, vy));
    }
    canvas.addEventListener("mousedown", input_pointerDown);
    canvas.addEventListener("touchstart", input_pointerDown);
    canvas.addEventListener("mousemove", input_pointerMove);
    canvas.addEventListener("touchmove", input_pointerMove);
    canvas.addEventListener("mouseup", input_pointerUp);
    canvas.addEventListener("touchend", input_pointerUp);
    
    // ================== MENU FUNCTIONS ==================
    function selectAvatar(avatar) {
      selectedAvatar = avatar;
      const exp = document.querySelector("#menuOverlay p.explanation");
      exp.innerHTML = exp.innerHTML.replace(/Selected: .*/,"") + `<br><br>Selected: ${avatar}`;
      document.getElementById("btnMona").classList.toggle("selected", avatar === "Mona");
      document.getElementById("btnJonas").classList.toggle("selected", avatar === "Jonas");
    }
    function startGame() {
      document.getElementById("menuOverlay").style.display = "none";
      gameState = "playing";
      player = new Player(selectedAvatar || "Mona");
      projectiles = [];
      targets = [];
      obstacles = [];
      decorations = [];
      clouds = [];
      birds = [];
      spaceStars = [];
      particles = [];
      pointAnimations = [];
      logMessages = [];
      rescuedPandas = [];
      scrollOffset = 0;
      score = 0;
      lastTime = 0;
      spawnTimer = 0;
      currentLevelIndex = 0;
      if (levels[currentLevelIndex].name !== "Space") {
        for (let i = 0; i < 5; i++) {
          clouds.push(new Cloud(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 10 + Math.random()*10, 30 + Math.random()*20));
        }
        for (let i = 0; i < 3; i++) {
          birds.push(new Bird(Math.random()*canvas.width, Math.random()*canvas.height*0.2, 50 + Math.random()*30));
        }
      } else {
        for (let i = 0; i < 50; i++) {
          spaceStars.push(new SpaceStar(Math.random()*canvas.width, Math.random()*canvas.height*0.2));
        }
      }
      requestAnimationFrame(gameLoop);
    }
    function pauseGame() {
      paused = true;
      gameState = "paused";
      document.getElementById("pauseOverlay").style.display = "flex";
    }
    function resumeGame() {
      paused = false;
      gameState = "playing";
      document.getElementById("pauseOverlay").style.display = "none";
      requestAnimationFrame(gameLoop);
    }
    function changeAvatar() {
      paused = false;
      gameState = "menu";
      document.getElementById("pauseOverlay").style.display = "none";
      document.getElementById("menuOverlay").style.display = "flex";
    }
    
    // ================== RESTART FUNCTION (for win screen "Play Again" button) ==================
    function restartGame() {
      changeAvatar();
    }
    
    // ================== END OF CODE ==================
  </script>
</body>
</html>
